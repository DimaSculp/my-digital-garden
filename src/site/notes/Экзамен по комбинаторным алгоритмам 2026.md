---
{"dg-publish":true,"permalink":"/ekzamen-po-kombinatornym-algoritmam-2026/","tags":["gardenEntry"]}
---

![IMG_0479.jpeg](/img/user/IMG_0479.jpeg)

# 1. Алгоритм построения пути в лабиринте с минимальным количеством изгибов
![IMG_0480.jpeg](/img/user/IMG_0480.jpeg)
![IMG_0481.jpeg](/img/user/IMG_0481.jpeg)
![IMG_0482.jpeg](/img/user/IMG_0482.jpeg)![IMG_0484.jpeg](/img/user/IMG_0484.jpeg)![IMG_0485.jpeg](/img/user/IMG_0485.jpeg)ответ от gimini:
##1. Суть задачи

- **Дано:** Сетка (лабиринт), начальная и конечная точки.
    
- **Цель:** Найти путь, в котором количество изменений направления движения минимально.
    
- **Особенность:** Длина пути (количество клеток) может быть больше, чем в кратчайшем пути, если это позволяет уменьшить число «колен».
    

---

## 2. Основные подходы

### А. Модифицированный BFS (Лучевой поиск)

Это наиболее интуитивный способ. Вместо того чтобы на каждом шаге BFS посещать только соседние клетки, мы «выстреливаем» лучами во всех доступных направлениях.

**Алгоритм:**

1. Поместить стартовую клетку в очередь. Установить `dist[start] = 0`.
    
2. Пока очередь не пуста:
    
    - Извлечь текущую клетку `(x, y)`.
        
    - Для каждого из 4-х направлений (вверх, вниз, влево, вправо):
        
        - Двигаться в этом направлении до упора (стена или граница).
            
        - Для каждой клетки на этом луче:
            
            - Если клетка еще не была посещена (или найден путь с меньшим числом поворотов):
                
                - Установить `dist[new_x][new_y] = dist[x][y] + 1`.
                    
                - Добавить новую клетку в очередь.
                    
3. Количество поворотов в итоге будет равно `dist[finish] - 1` (так как первый «луч» — это еще не поворот).
    

---

### Б. Алгоритм 0-1 BFS (Оптимальный)

Более эффективный метод, использующий дек (двустороннюю очередь). Мы представляем состояние не просто как координаты `(x, y)`, а как тройку `(x, y, direction)`.

**Логика переходов:**

- Если мы продолжаем движение в том же направлении `direction` → вес ребра = **0** (добавляем в начало дека).
    
- Если мы меняем направление → вес ребра = **1** (добавляем в конец дека).
    

---

## 3. Сравнение с алгоритмом Ли

|Характеристика|Алгоритм Ли (BFS)|Мин. количество изгибов|
|---|---|---|
|**Что минимизирует**|Длину пути (клетки)|Количество поворотов|
|**Структура данных**|Обычная очередь|Дек или Очередь с приоритетом|
|**Сложность**|O(V+E)|O(k⋅(V+E)), где k — число направлений|## 1. Суть задачи

- **Дано:** Сетка (лабиринт), начальная и конечная точки.
    
- **Цель:** Найти путь, в котором количество изменений направления движения минимально.
    
- **Особенность:** Длина пути (количество клеток) может быть больше, чем в кратчайшем пути, если это позволяет уменьшить число «колен».
    

---

## 2. Основные подходы

### А. Модифицированный BFS (Лучевой поиск)

Это наиболее интуитивный способ. Вместо того чтобы на каждом шаге BFS посещать только соседние клетки, мы «выстреливаем» лучами во всех доступных направлениях.

**Алгоритм:**

1. Поместить стартовую клетку в очередь. Установить `dist[start] = 0`.
    
2. Пока очередь не пуста:
    
    - Извлечь текущую клетку `(x, y)`.
        
    - Для каждого из 4-х направлений (вверх, вниз, влево, вправо):
        
        - Двигаться в этом направлении до упора (стена или граница).
            
        - Для каждой клетки на этом луче:
            
            - Если клетка еще не была посещена (или найден путь с меньшим числом поворотов):
                
                - Установить `dist[new_x][new_y] = dist[x][y] + 1`.
                    
                - Добавить новую клетку в очередь.
                    
3. Количество поворотов в итоге будет равно `dist[finish] - 1` (так как первый «луч» — это еще не поворот).
    

---

### Б. Алгоритм 0-1 BFS (Оптимальный)

Более эффективный метод, использующий дек (двустороннюю очередь). Мы представляем состояние не просто как координаты `(x, y)`, а как тройку `(x, y, direction)`.

**Логика переходов:**

- Если мы продолжаем движение в том же направлении `direction` → вес ребра = **0** (добавляем в начало дека).
    
- Если мы меняем направление → вес ребра = **1** (добавляем в конец дека).
    

---

## 3. Сравнение с алгоритмом Ли

|Характеристика|Алгоритм Ли (BFS)|Мин. количество изгибов|
|---|---|---|
|**Что минимизирует**|Длину пути (клетки)|Количество поворотов|
|**Структура данных**|Обычная очередь|Дек или Очередь с приоритетом|
|**Сложность**|O(V+E)|O(k⋅(V+E)), где k — число направлений|
`def min_turns_path(maze, start, end): 
	rows, cols = len(maze), len(maze[0]) 
	# dist[r][c] хранит минимальное количество сегментов до клетки 
	dist = [[float('inf')] * cols for _ in range(rows)] 
	queue = deque([start])
	 dist[start[0]][start[1]] = 0
	 
	 while queue: 
		 r, c = queue.popleft() 
		 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
			  nr, nc = r + dr, c + dc # Идем лучом в одном направлении 
			  while 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 0: 
				  if dist[nr][nc] > dist[r][c] + 1:
					   dist[nr][nc] = dist[r][c] + 1 queue.append((nr, nc))
				  nr += dr 
				  nc += dc
	return dist[end[0]][end[1]] - 1`

# 2.Основные понятия теории графов. Теорема об эквивалентности различных условий в дереве
![IMG_0486.jpeg](/img/user/IMG_0486.jpeg)![IMG_0487.jpeg](/img/user/IMG_0487.jpeg)![IMG_0488.jpeg](/img/user/IMG_0488.jpeg)
![IMG_0489.jpeg](/img/user/IMG_0489.jpeg)
![IMG_0490.jpeg](/img/user/IMG_0490.jpeg)
**Граф** G=(V,E) — это математическая структура, состоящая из:

- **V (Vertices)** — непустое множество **вершин** (узлов).
    
- **E (Edges)** — множество **ребер** (связей), соединяющих пары вершин.
    

### Ключевые термины:

- **Смежные вершины** — две вершины, соединенные ребром.
    
- **Инцидентность** — ребро инцидентно вершине, если оно её соединяет.
    
- **Степень вершины** d(v) — количество ребер, выходящих из вершины v.
    
- **Путь** — последовательность вершин, в которой каждая следующая соединена с предыдущей ребром.
    
- **Цикл** — путь, в котором первая и последняя вершины совпадают.
    
- **Связный граф** — граф, в котором между любыми двумя вершинами существует путь.
    

---

## 2. Деревья

**Дерево** — это связный ациклический (не содержащий циклов) граф.

---

## 3. Теорема об эквивалентных определениях дерева

Это фундаментальная теорема. Пусть G=(V,E) — обычный граф с n вершинами. Следующие утверждения **эквивалентны** (если выполняется одно, то выполняются и все остальные):

1. **Определение:** G — связный и не содержит циклов.
    
2. **Минимальная связность:** G — связный, но после удаления любого ребра он перестает быть связным.
    
3. **Максимальная ацикличность:** G не содержит циклов, но при добавлении любого нового ребра между существующими вершинами образуется ровно один цикл.
    
4. **Единственность пути:** Между любыми двумя вершинами графа G существует **ровно один** простой путь.
    
5. **Связность + Число ребер:** G связный и содержит ровно n−1 ребро.
    
6. **Ацикличность + Число ребер:** G не содержит циклов и содержит ровно n−1 ребро.
    

---

## 4. Свойства деревьев (для экзамена)

- **Лист** — вершина степени 1. В любом конечном дереве (n>1) есть как минимум два листа.
    
- **Лес** — граф, каждая компонента связности которого является деревом (граф без циклов).
    
- **Остовное дерево** — подграф данного связного графа, который содержит все его вершины и является деревом.
# 3.Задача о минимальном остове. Основная лемма.
![IMG_0491.jpeg](/img/user/IMG_0491.jpeg)![IMG_0492.jpeg](/img/user/IMG_0492.jpeg)![IMG_0493.jpeg](/img/user/IMG_0493.jpeg)
![IMG_0494.jpeg](/img/user/IMG_0494.jpeg)## Постановка задачи

**Дано:** Связный неориентированный граф G=(V,E) с весовыми коэффициентами ребер w(u,v). **Цель:** Найти подмножество ребер T⊆E, которое:

1. Связывает все вершины графа (образует остов).
    
2. Не содержит циклов (является деревом).
    
3. Имеет минимальный суммарный вес: w(T)=∑(u,v)∈T​w(u,v)→min.
    

---

## 2. Основная лемма (Лемма о разрезе)

Эта лемма лежит в основе почти всех жадных алгоритмов поиска MST (Прима, Краскала, Борувки).

### Определения:

- **Разрез** (S,V−S) — это разбиение множества вершин на два непересекающихся множества.
    
- **Ребро пересекает разрез**, если один его конец лежит в S, а другой в V−S.
    
- **Безопасное ребро** — ребро, которое можно добавить к строящемуся остову, не нарушая возможности достроить его до минимального.
    

### Формулировка леммы:

Пусть A — подмножество ребер, входящее в некотороe MST графа G. Пусть (S,V−S) — любой разрез графа G, который не пересекается ребрами из A. Пусть e=(u,v) — ребро с **минимальным весом** среди всех ребер, пересекающих этот разрез. **Тогда ребро e является безопасным для A.**

---

## 3. Идея доказательства (от противного)

1. Пусть есть некоторое MST T, которое не содержит наше минимальное ребро e.
    
2. Если мы добавим e к T, образуется цикл.
    
3. В этом цикле обязательно должно быть другое ребро e′, которое также пересекает разрез (S,V−S).
    
4. Так как w(e)≤w(e′) (по условию, что e — минимальное на разрезе), мы можем заменить e′ на e.
    
5. Вес нового дерева T′=T−{e′}+{e} будет w(T′)≤w(T).
    
6. Значит, T′ — тоже MST, и ребро e в него входит.
    

---

## 4. Алгоритмы решения

Для построения MST используются «жадные» стратегии:

1. **Алгоритм Краскала:** Сортируем все ребра по весу и добавляем их в граф, если они не образуют цикл (используется DSU — система непересекающихся множеств).
    
2. **Алгоритм Прима:** Начинаем с одной вершины и на каждом шагу добавляем самое легкое ребро, соединяющее уже построенную часть дерева с новой вершиной.
    

---

### Шпаргалка для ответа на экзамене:

- **Сложность Краскала:** O(ElogE) или O(ElogV).
    
- **Сложность Прима:** O(ElogV) с бинарной кучей или O(E+VlogV) с фибоначчиевой кучей.
    
- **Условие единственности:** Если веса всех ребер в графе различны, то MST единственно.
# 4.Алгоритм Борувки-Краскла.

![IMG_0495.jpeg](/img/user/IMG_0495.jpeg)![IMG_0496.jpeg](/img/user/IMG_0496.jpeg)![IMG_0497.jpeg](/img/user/IMG_0497.jpeg)## 1. Алгоритм Краскала (Kruskal's Algorithm)

Самый популярный алгоритм для ручного решения задач и реализации на соревнованиях.

### Суть:

Мы рассматриваем граф как лес, где каждая вершина — отдельное дерево. Мы последовательно объединяем эти деревья в одно, выбирая самые легкие ребра.

### Алгоритм:

1. Отсортировать все ребра графа по возрастанию их веса.
    
2. Создать структуру **DSU (Система непересекающихся множеств)**, где изначально каждая вершина сама по себе.
    
3. Проходить по отсортированному списку ребер (u,v):
    
    - Если u и v находятся в разных компонентах связности (проверка через DSU):
        
        - Добавить ребро (u,v) в MST.
            
        - Объединить компоненты u и v в DSU.
            
    - Если они в одной компоненте — пропустить (чтобы не было цикла).
        
4. Повторять, пока не наберется n−1 ребро.
    

### Сложность:

- O(ElogE) или O(ElogV) — основное время уходит на сортировку ребер.
## 2. Алгоритм Борувки (Borůvka's Algorithm)

Исторически первый алгоритм (1926 г.). Он хорошо подходит для параллельных вычислений.

### Суть:

На каждой итерации каждая компонента связности одновременно выбирает свое минимальное инцидентное ребро и «голосует» за него.

### Алгоритм:

1. Изначально каждая вершина — это отдельная компонента.
    
2. Пока количество компонент больше 1:
    
    - Для каждой компоненты найти ребро **минимального веса**, которое соединяет её с **другой**компонентой.
        
    - Добавить все найденные ребра в MST (одинаковые ребра от разных компонент добавляются один раз).
        
    - Объединить компоненты, связанные выбранными ребрами.
        
3. С каждой итерацией количество компонент уменьшается как минимум вдвое.
    

### Сложность:

- O(ElogV). Всего будет не более logV итераций, на каждой из которых мы перебираем все ребра O(E).
## Сравнение алгоритмов

|Характеристика|Алгоритм Краскала|Алгоритм Борувки|
|---|---|---|
|**Главная идея**|Сортировка ребер|Одновременный выбор из компонент|
|**Сложность**|O(ElogE)|O(ElogV)|
|**Параллелизм**|Плохо распараллеливается|Отлично распараллеливается|
|**Когда лучше**|На разреженных графах|В распределенных системах|

# 5.Алгоритм Ярника-Прима-Дейкстры.
![IMG_0498.jpeg](/img/user/IMG_0498.jpeg)![IMG_0499.jpeg](/img/user/IMG_0499.jpeg) # Алгоритм Прима (Ярника-Прима-Дейкстры)

Согласно учебнику Асанова и Расина, этот алгоритм является одной из реализаций общей «жадной» стратегии построения минимального остовного дерева (MST).

## 1. Суть алгоритма (Стратегия «Растущего дерева»)

Алгоритм реализует так называемую **Стратегию 2** построения остова:

- В отличие от алгоритма Краскала, который может одновременно строить несколько компонент связности, алгоритм Прима на каждом шаге поддерживает **ровно одну** неодноэлементную компоненту связности Hi​.
    
- Эту компоненту часто называют «растущим деревом».
    

## 2. Пошаговое описание

Пусть G=(V,E) — связный взвешенный граф с n вершинами.

1. **Инициализация:** В качестве начального дерева H0​ выбирается произвольная вершина графа G.
    
2. **Итерационный шаг:** Пусть дерево Hi​ (где 0≤i<n−1) уже построено.
    
3. **Выбор ребра:** Из множества всех ребер, соединяющих вершины дерева Hi​ с вершинами вне него (Ext(Hi​)), выбирается ребро ei+1​ **минимального веса**.
    
4. **Расширение:** Новое дерево Hi+1​ получается путем добавления ребра ei+1​ к дереву Hi​ (Hi+1​=Hi​+ei+1​).
    
5. **Завершение:** Процесс повторяется n−1 раз, пока не будет построен минимальный остов Hn−1​.
    

## 3. Почему алгоритм связывают с Дейкстрой и Ярником?

Хотя в учебнике основной упор сделан на названии «Алгоритм Прима», в научной литературе его часто называют именами трех ученых:

- **Ярник (1930):** Впервые описал этот метод.
    
- **Прим (1957):** Независимо открыл и популяризировал его.
    
- **Дейкстра (1959):** Использовал аналогичную структуру меток и приоритетную очередь для поиска кратчайших путей (алгоритм Дейкстры), что делает программную реализацию обоих алгоритмов почти идентичной.
    

## 4. Сравнение с алгоритмом Краскала (по учебнику)

|Характеристика|Алгоритм Краскала|Алгоритм Прима|
|---|---|---|
|**Стратегия**|Слияние лесов (минимальное из всех внешних ребер)|Рост одного дерева (минимальное из ребер, выходящих из дерева)|
|**Структура данных**|Система непересекающихся множеств (DSU)|Приоритетная очередь (метки вершин)|
|**Сложность**|O(ElogE)|O(ElogV) (с использованием кучи)|

## 5. Заметки для экзамена

- **Обоснование:** Алгоритм корректен благодаря «Основной лемме» (лемме о разрезе): на каждом шаге мы выбираем минимальное ребро, пересекающее разрез между деревом и остальными вершинами.
    
- **Жадный выбор:** Алгоритм является классическим примером жадного алгоритма, который на каждом шаге принимает локально оптимальное решение, приводящее к глобальному оптимуму.
    
- **Случай нескольких MST:** Если в графе есть ребра с одинаковым весом, алгоритм Прима построит один из возможных минимальных остовов.

# 6.Задача о кратчайшем пути в сети. Алгоритм Форда-Беллмана.
![IMG_0500.jpeg](/img/user/IMG_0500.jpeg)![IMG_0501.jpeg](/img/user/IMG_0501.jpeg)![IMG_0502.jpeg](/img/user/IMG_0502.jpeg)![IMG_0503.jpeg](/img/user/IMG_0503.jpeg)![IMG_0504.jpeg](/img/user/IMG_0504.jpeg)![IMG_0505.jpeg](/img/user/IMG_0505.jpeg)# Задача о кратчайшем пути и алгоритм Форда-Беллмана

## 1. Постановка задачи о кратчайшем пути (ЗКП)

Согласно учебнику, взвешенный орграф G=(V,E,c) называется **сетью**.

- **Длина пути:** Если P — это путь v0​→v1​→⋯→vk​, то его длиной c(P) называется сумма весов всех входящих в него дуг.
- **Расстояние:** Наименьшая из длин всех возможных (v,w)-путей называется расстоянием от v до w.
- **Суть задачи:** В заданной сети с двумя выделенными вершинами s (источник) и t (сток) требуется найти кратчайший (s,t)-путь.
---

## 2. Алгоритм Форда-Беллмана: Общий случай

Этот алгоритм применяется для решения ЗКП в общем случае, когда веса дуг могут быть **отрицательными**.
### Основные условия и ограничения:

- **Отсутствие контуров отрицательной длины:** Алгоритм работает корректно только в сетях, где нет циклов с отрицательной суммой весов.
- Если такой контур существует, расстояние становится неопределенным, так как, обходя его бесконечно, можно получить путь сколь угодно малой длины.
- **Динамическое программирование:** Метод основан на поэтапном вычислении кратчайших расстояний.

---

## 3. Идея и реализация алгоритма

Алгоритм вычисляет dk​(v) — длину кратчайшего пути от s до v, содержащего **не более чем k дуг**.
### Основная формула пересчета:

Для вычисления пути из k+1 дуги используется рекуррентное соотношение:
dk+1​(v)=min{dk​(v),w∈Vmin​{dk​(w)+c(w,v)}}

### Процесс (прямой и обратный ход):

1. **Прямой ход:** Разметка всех вершин и вычисление расстояний от s до всех остальных вершин за n−1итерацию.

2. **Обратный ход:** Построение самого пути с помощью массива меток `Previous[v]`, где хранится имя вершины, предшествующей v в кратчайшем пути.

## 4. Сложность алгоритма

- **В общем случае (матрица весов):** Сложность составляет **O(n3)**, так как используется три вложенных цикла (по количеству дуг k, по вершинам v и по вершинам w
    
- **При использовании списков смежности:** Если сеть задана списками исходящих дуг, сложность снижается до **O(mn)**, где m — число дуг, а n — число вершин.
---

## 5. Псевдокод (по алгоритму 4.1 из учебника)

Delphi

```
procedure Distance;
begin
  D[s] := 0; Previous[s] := 0;
  for v in V \ {s} do
    begin D[v] := A[s, v]; Previous[v] := s end;
    for k := 1 to n - 2 do
    for v in V \ {s} do
      for w in V do
        if D[w] + A[w, v] < D[v] then
          begin
            D[v] := D[w] + A[w, v];
            Previous[v] := w
          end
end;
```


# 7.Задача о конвертации валют.
В учебнике и в конспектов сани не нашел
### 1. Математическая модель

В задаче о конвертации (или поиске арбитража):

- **Вершины графа** — это различные валюты (USD, EUR, RUB и т. д.).
    
- **Дуги графа** — возможность обмена одной валюты на другую.
    
- **Веса дуг (rij​)** — курсы обмена (коэффициенты, на которые умножается сумма).
    

При последовательном обмене по пути v1​→v2​→⋯→vk​ итоговый коэффициент вычисляется как **произведение** курсов: R=r12​⋅r23​⋅⋯⋅rk−1,k​.

### 2. Сведение к задаче о кратчайшем пути

Алгоритмы поиска кратчайших путей (Форд-Беллман, Дейкстра) работают с **суммой** весов дуг. Чтобы превратить произведение курсов в сумму, используется свойство логарифмов:

log(r1​⋅r2​⋅⋯⋅rn​)=logr1​+logr2​+⋯+logrn​

Чтобы задача поиска «максимальной выгоды» превратилась в задачу поиска «минимального пути», веса дуг заменяются на:

wij​=−logrij​

### 3. Арбитраж и отрицательные циклы

В разделе 4.2 учебника указано, что алгоритм Форда-Беллмана работает корректно при отсутствии **контуров отрицательной длины**.

- В задаче о валютах **отрицательный цикл** в графе логарифмов соответствует циклу обмена, в котором произведение курсов >1.
    
- Это и есть **арбитраж** — возможность совершить круг обменов и получить прибыль из ничего.
    
- Алгоритм Форда-Беллмана позволяет обнаружить такой цикл на n-й итерации (если значение метки вершины продолжает уменьшаться).
    

**Резюме для ответа:** Хотя прямой задачи о валютах в книге нет, она решается с помощью описанного в ней **алгоритма Форда-Беллмана (раздел 4.2)** путём логарифмирования весов дуг для перехода от произведений к суммам.

# 8.Задача о кратчайшем пути в сети с неотрицательными весами.
![IMG_0506.jpeg](/img/user/IMG_0506.jpeg)# Алгоритм Дейкстры (Алгоритм 4.2)

Этот алгоритм предназначен для нахождения расстояний от фиксированной вершины до всех остальных в сети, где веса всех дуг **неотрицательны** (c(e)≥0).

## 1. Основная идея

Алгоритм последовательно расширяет множество вершин S, для которых кратчайшее расстояние от источника sуже вычислено. На каждом шаге к множеству S добавляется вершина w из множества «необработанных» вершин F=V∖S, имеющая минимальное текущее значение метки D[w].

## 2. Формальное описание алгоритма

**Вход:**

- Сеть G=(V,E,c), заданная матрицей весов A порядка n.
    
- Выделенная вершина (источник) s.
    

**Выход:**

- Массив D[v] — расстояния от s до всех вершин v∈V.
    
- Массив Previous[v] — предпоследняя вершина в кратчайшем (s,v)-пути.
    

### Шаги алгоритма:

1. **Инициализация:**
    
    - Установить D[s]:=0, Previous[s]:=0.
        
    - Определить множество необработанных вершин F:=V∖{s}.
        
    - Для каждой вершины v∈F задать начальные значения: D[v]:=A[s,v], Previous[v]:=s.
        
2. **Основной цикл (повторяется n−1 раз):**
    
    - Найти вершину w∈F, для которой D[w] минимально (функция Min(F)).
        
    - Исключить w из множества F (F:=F∖{w}).
        
    - **Пересчет меток:** Для каждой вершины v, оставшейся в F, проверить условие: Если D[w]+A[w,v]<D[v], то обновить: D[v]:=D[w]+A[w,v] Previous[v]:=w.
        

## 3. Сложность и замечания

- **Сложность:** При использовании простейших структур данных сложность составляет **O(n2)**. При использовании приоритетных очередей (куч) сложность может быть доведена до **O(mlogn)** или **O(m+nlogn)**.
    
- **Ограничение:** Алгоритм работает корректно **только при неотрицательных весах** дуг. Если в сети есть дуги с отрицательным весом, следует использовать алгоритм Форда-Беллмана.
    
- **Связь с другими алгоритмами:** Метод выбора минимального ребра на каждом шаге аналогичен технике, применяемой в алгоритме Ярника-Прима для поиска минимального остова.
    

---

### Пример структуры кода из учебника:

Delphi

```
for k := 1 to n - 1 do
begin
  w := Min(F);
  F := F \ {w};
  for v in F do
    if D[w] + A[w, v] < D[v] then
    begin
      D[v] := D[w] + A[w, v];
      Previous[v] := w;
    end
end;
```